{"code":"import * as alt from 'alt';\r\nimport * as game from 'natives';\r\nexport class Calculation {\r\n    static distance(distOne, distTwo) {\r\n        const dist = Math.pow(distOne.x - distTwo.x, 2) + Math.pow(distOne.y - distTwo.y, 2) + Math.pow(distOne.z - distTwo.z, 2);\r\n        return dist;\r\n    }\r\n    static forwardVectorFromRotation(rotation) {\r\n        const z = rotation.z * (Math.PI / 180.0);\r\n        const x = rotation.x * (Math.PI / 180.0);\r\n        const num = Math.abs(Math.cos(x));\r\n        return new alt.Vector3(-Math.sin(z) * num, Math.cos(z) * num, Math.sin(x));\r\n    }\r\n    static positionInFront(position, rotation, distance) {\r\n        const forwardVector = Calculation.forwardVectorFromRotation(rotation);\r\n        const scaledForwardVector = new alt.Vector3(forwardVector.x * distance, forwardVector.y * distance, forwardVector.z * distance);\r\n        return new alt.Vector3(position.x + scaledForwardVector.x, position.y + scaledForwardVector.y, position.z + scaledForwardVector.z);\r\n    }\r\n    static probability(percent) {\r\n        const randNumber = Math.floor(Math.random() * 100) + 1;\r\n        alt.log(`Wylosowana liczba: ${randNumber}`);\r\n        if (randNumber > 0 && randNumber <= percent) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    static getVehicleInRange(pos, range) {\r\n        const vehicles = alt.Vehicle.all.find(x => this.positionInFront(alt.Player.local.pos, game.getEntityRotation(alt.Player.local.scriptID, 2), range) <= pos);\r\n        return vehicles;\r\n    }\r\n    static isPlayerInRange(senderPos, getterPos, range) {\r\n        return (Calculation.distance(senderPos, getterPos) <= range);\r\n    }\r\n    static getOffsetPositionInWorldCoords(entityHandle, offset) {\r\n        return game.getOffsetFromEntityInWorldCoords(entityHandle, offset.x, offset.y, offset.z);\r\n    }\r\n    static getEntityRearPosition(entityHandle) {\r\n        const modelDimensions = game.getModelDimensions(game.getEntityModel(entityHandle), undefined, undefined);\r\n        return this.getOffsetPositionInWorldCoords(entityHandle, new alt.Vector3(0, modelDimensions[1].y, 0));\r\n    }\r\n    static rotationToDirection(rotation) {\r\n        const z = Calculation.degToRad(rotation.z);\r\n        const x = Calculation.degToRad(rotation.x);\r\n        const num = Math.abs(Math.cos(x));\r\n        const result = {};\r\n        result.x = (-Math.sin(z) * num);\r\n        result.y = (Math.cos(z) * num);\r\n        result.z = Math.sin(x);\r\n        return result;\r\n    }\r\n    static processCoordinates(x, y) {\r\n        const res = game.getActiveScreenResolution(0, 0);\r\n        const screenX = res[1];\r\n        const screenY = res[2];\r\n        let relativeX = (1 - ((x / screenX) * 1.0) * 2);\r\n        let relativeY = (1 - ((y / screenY) * 1.0) * 2);\r\n        if (relativeX > 0.0) {\r\n            relativeX = -relativeX;\r\n        }\r\n        else {\r\n            relativeX = Math.abs(relativeX);\r\n        }\r\n        if (relativeY > 0.0) {\r\n            relativeY = -relativeY;\r\n        }\r\n        else {\r\n            relativeY = Math.abs(relativeY);\r\n        }\r\n        return { x: relativeX, y: relativeY };\r\n    }\r\n    static degToRad(deg) {\r\n        return deg * Math.PI / 180.0;\r\n    }\r\n    static mulNumber(vector1, value) {\r\n        const result = {};\r\n        result.x = vector1.x * value;\r\n        result.y = vector1.y * value;\r\n        result.z = vector1.z * value;\r\n        return result;\r\n    }\r\n    static w2s(position) {\r\n        const result = game.getScreenCoordFromWorldCoord(position.x, position.y, position.z, undefined, undefined);\r\n        if (!result[0]) {\r\n            return undefined;\r\n        }\r\n        const newPos = {};\r\n        newPos.x = (result[1] - 0.5) * 2;\r\n        newPos.y = (result[2] - 0.5) * 2;\r\n        newPos.z = 0;\r\n        return newPos;\r\n    }\r\n    static subVector3(vector1, vector2) {\r\n        return {\r\n            x: vector1.x - vector2.x,\r\n            y: vector1.y - vector2.y,\r\n            z: vector1.z - vector2.z,\r\n        };\r\n    }\r\n    static addVector3(vector1, vector2) {\r\n        return {\r\n            x: vector1.x + vector2.x,\r\n            y: vector1.y + vector2.y,\r\n            z: vector1.z + vector2.z,\r\n        };\r\n    }\r\n    static getMousePOSAbs() {\r\n        const x = game.getControlNormal(0, 239);\r\n        const y = game.getControlNormal(0, 240);\r\n        const screenRes = game.getActiveScreenResolution(0, 0);\r\n        const actualX = screenRes[1] * x;\r\n        const actualY = screenRes[2] * y;\r\n        return { x: actualX, y: actualY };\r\n    }\r\n    static s2w(camPos, relX, relY) {\r\n        const camRot = game.getGameplayCamRot(0);\r\n        const camForward = Calculation.rotationToDirection(camRot);\r\n        const rotUp = Calculation.addVector3(camRot, { x: 10, y: 0, z: 0 });\r\n        const rotDown = Calculation.addVector3(camRot, { x: -10, y: 0, z: 0 });\r\n        const rotLeft = Calculation.addVector3(camRot, { x: 0, y: 0, z: -10 });\r\n        const rotRight = Calculation.addVector3(camRot, { x: 0, y: 0, z: 10 });\r\n        const camRight = Calculation.subVector3(Calculation.rotationToDirection(rotRight), Calculation.rotationToDirection(rotLeft));\r\n        const camUp = Calculation.subVector3(Calculation.rotationToDirection(rotUp), Calculation.rotationToDirection(rotDown));\r\n        const rollRad = -Calculation.degToRad(camRot.y);\r\n        const camRightRoll = Calculation.subVector3(Calculation.mulNumber(camRight, Math.cos(rollRad)), Calculation.mulNumber(camUp, Math.sin(rollRad)));\r\n        const camUpRoll = Calculation.addVector3(Calculation.mulNumber(camRight, Math.sin(rollRad)), Calculation.mulNumber(camUp, Math.cos(rollRad)));\r\n        const point3D = Calculation.addVector3(Calculation.addVector3(Calculation.addVector3(camPos, Calculation.mulNumber(camForward, 10.0)), camRightRoll), camUpRoll);\r\n        const point2D = Calculation.w2s(point3D);\r\n        if (point2D === undefined) {\r\n            return Calculation.addVector3(camPos, Calculation.mulNumber(camForward, 10.0));\r\n        }\r\n        const point3DZero = Calculation.addVector3(camPos, Calculation.mulNumber(camForward, 10.0));\r\n        const point2DZero = Calculation.w2s(point3DZero);\r\n        if (point2DZero === undefined) {\r\n            return Calculation.addVector3(camPos, Calculation.mulNumber(camForward, 10.0));\r\n        }\r\n        const eps = 0.001;\r\n        if (Math.abs(point2D.x - point2DZero.x) < eps || Math.abs(point2D.y - point2DZero.y) < eps) {\r\n            return Calculation.addVector3(camPos, Calculation.mulNumber(camForward, 10.0));\r\n        }\r\n        const scaleX = (relX - point2DZero.x) / (point2D.x - point2DZero.x);\r\n        const scaleY = (relY - point2DZero.y) / (point2D.y - point2DZero.y);\r\n        const point3Dret = Calculation.addVector3(Calculation.addVector3(Calculation.addVector3(camPos, Calculation.mulNumber(camForward, 10.0)), Calculation.mulNumber(camRightRoll, scaleX)), Calculation.mulNumber(camUpRoll, scaleY));\r\n        return point3Dret;\r\n    }\r\n    static screen2dToWorld3dPosition(absoluteX, absoluteY, flags, ignore, callback) {\r\n        const camPos = game.getGameplayCamCoord();\r\n        const processedCoords = Calculation.processCoordinates(absoluteX, absoluteY);\r\n        const target = Calculation.s2w(camPos, processedCoords.x, processedCoords.y);\r\n        const dir = Calculation.subVector3(target, camPos);\r\n        const from = Calculation.addVector3(camPos, Calculation.mulNumber(dir, 0.05));\r\n        const to = Calculation.addVector3(camPos, Calculation.mulNumber(dir, 300));\r\n        const ray = game.startShapeTestRay(from.x, from.y, from.z, to.x, to.y, to.z, flags, ignore, 0);\r\n        const result = game.getShapeTestResult(ray, undefined, undefined, undefined, undefined);\r\n        callback(result);\r\n    }\r\n}\r\n","references":[]}
