{"code":"import * as alt from 'alt';\r\nimport * as natives from 'natives';\r\nimport { asyncModel } from './AsyncModel';\r\nconst OBJECT_TYPES = {\r\n    OBJECT: 0,\r\n    RWO: 1,\r\n};\r\nclass ObjectStreamer {\r\n    constructor() {\r\n        this.objects = [];\r\n    }\r\n    async addObject(entityId, model, entityType, pos, rot, lodDistance, textureVariation, dynamic, visible, onFire, frozen, lightColor) {\r\n        this.removeObject(entityId, entityType);\r\n        this.clearObject(entityId, entityType);\r\n        if (!await asyncModel.load(+entityId, model)) {\r\n            return alt.log(`[OBJECT-STREAMER] Couldn't create object with model ${model}.`);\r\n        }\r\n        const handle = natives.createObjectNoOffset(model, pos.x, pos.y, pos.z, true, true, false);\r\n        const obj = { handle, entityId: +entityId, model, entityType, position: pos, move: null };\r\n        this.objects.push(obj);\r\n        this.setRotation(obj, rot);\r\n        this.setLodDistance(obj, lodDistance);\r\n        this.setTextureVariation(obj, textureVariation);\r\n        this.setDynamic(obj, dynamic);\r\n        this.setVisible(obj, visible);\r\n        this.setOnFire(obj, onFire);\r\n        this.setFrozen(obj, frozen);\r\n        this.setLightColor(obj, lightColor);\r\n    }\r\n    removeWorldObject(entityId, position, model, radius, entityType) {\r\n        const handle = natives.getClosestObjectOfType(position.x, position.y, position.z, +radius, model, false, true, true);\r\n        alt.log(`remove world object: ${entityId}, ${model}, ${handle}`);\r\n        if (handle !== 0) {\r\n            alt.log('handle is valid');\r\n            natives.setEntityCollision(+handle, false, false);\r\n            natives.setEntityVisible(+handle, false, false);\r\n        }\r\n        this.objects.push({ handle, entityId: +entityId, model, entityType, radius, position });\r\n    }\r\n    getObject(entityId, entityType) {\r\n        const obj = this.objects.find(o => +o.entityId === +entityId && +o.entityType === +entityType);\r\n        if (!obj) {\r\n            return null;\r\n        }\r\n        return obj;\r\n    }\r\n    getObjectByHandleId(handleId) {\r\n        return this.objects.find(x => x.handle === handleId);\r\n    }\r\n    async restoreObject(entityId, entityType) {\r\n        const obj = this.getObject(entityId, entityType);\r\n        if (obj === null) {\r\n            return;\r\n        }\r\n        if (entityType === OBJECT_TYPES.RWO) {\r\n            natives.setEntityCollision(+obj.handle, false, false);\r\n            natives.setEntityVisible(+obj.handle, false, false);\r\n            return;\r\n        }\r\n        if (!await asyncModel.load(+entityId, obj.model)) {\r\n            return alt.log(`[OBJECT-STREAMER] Couldn't create object with model ${obj.model}.`);\r\n        }\r\n        obj.handle = natives.createObjectNoOffset(natives.getHashKey(obj.model), obj.position.x, obj.position.y, obj.position.z, true, true, false);\r\n        this.setRotation(obj, obj.rotation);\r\n        this.setLodDistance(obj, obj.lodDistance);\r\n        this.setTextureVariation(obj, obj.textureVariation);\r\n        this.setDynamic(obj, obj.dynamic);\r\n        this.setVisible(obj, obj.visible);\r\n        this.setOnFire(obj, obj.onFire);\r\n        this.setFrozen(obj, obj.frozen);\r\n        this.setLightColor(obj, obj.lightColor);\r\n    }\r\n    removeObject(entityId, entityType) {\r\n        const obj = this.getObject(entityId, entityType);\r\n        if (obj === null) {\r\n            return;\r\n        }\r\n        if (entityType === OBJECT_TYPES.RWO) {\r\n            natives.setEntityCollision(+obj.handle, true, true);\r\n            natives.setEntityVisible(+obj.handle, true, false);\r\n            return;\r\n        }\r\n        asyncModel.cancel(+entityId);\r\n        natives.deleteObject(+obj.handle);\r\n        obj.handle = null;\r\n    }\r\n    clearObject(entityId, entityType) {\r\n        const idx = this.objects.findIndex(o => +o.entityId === +entityId && +o.entityType === +entityType);\r\n        if (idx === -1) {\r\n            return;\r\n        }\r\n        this.objects.splice(idx, 1);\r\n    }\r\n    setRotation(obj, rot) {\r\n        natives.setEntityRotation(+obj.handle, rot.x, rot.y, rot.z, 2, false);\r\n        obj.rotation = rot;\r\n    }\r\n    setPosition(obj, pos) {\r\n        if (obj.move !== null) {\r\n            return;\r\n        }\r\n        natives.setEntityCoordsNoOffset(+obj.handle, pos.x, pos.y, pos.z, true, true, true);\r\n        obj.position = pos;\r\n    }\r\n    async setModel(obj, model) {\r\n        if (obj.entityType !== OBJECT_TYPES.RWO) {\r\n            if (!await asyncModel.load(+obj.entityId, model)) {\r\n                return alt.log(`[OBJECT-STREAMER] Couldn't load model ${model}.`);\r\n            }\r\n            natives.createModelSwap(obj.position.x, obj.position.y, obj.position.z, 2, natives.getHashKey(obj.model), natives.getHashKey(model), true);\r\n        }\r\n        obj.model = model;\r\n    }\r\n    setLodDistance(obj, lodDistance) {\r\n        if (lodDistance === null) {\r\n            return;\r\n        }\r\n        natives.setEntityLodDist(+obj.handle, +lodDistance);\r\n        obj.lodDistance = lodDistance;\r\n    }\r\n    setRadius(obj, radius) {\r\n        if (radius === null) {\r\n            return;\r\n        }\r\n        obj.radius = radius;\r\n    }\r\n    setTextureVariation(obj, textureVariation) {\r\n        if (textureVariation === null) {\r\n            if (obj.textureVariation !== null) {\r\n                natives.setObjectTextureVariation(+obj.handle, +textureVariation);\r\n                obj.textureVariation = null;\r\n            }\r\n            return;\r\n        }\r\n        natives.setObjectTextureVariation(+obj.handle, +textureVariation);\r\n        obj.textureVariation = textureVariation;\r\n    }\r\n    setDynamic(obj, dynamic) {\r\n        if (dynamic === null) {\r\n            return;\r\n        }\r\n        natives.setEntityDynamic(+obj.handle, !!dynamic);\r\n        obj.dynamic = !!dynamic;\r\n    }\r\n    setVisible(obj, visible) {\r\n        if (visible === null) {\r\n            return;\r\n        }\r\n        natives.setEntityVisible(+obj.handle, !!visible, false);\r\n        obj.textureVariation = !!visible;\r\n    }\r\n    setOnFire(obj, onFire) {\r\n        if (onFire === null) {\r\n            return;\r\n        }\r\n        if (!!onFire) {\r\n            obj.fireHandle = natives.startScriptFire(obj.position.x, obj.position.y, obj.position.z, 1, true);\r\n        }\r\n        else {\r\n            if (obj.fireHandle !== null) {\r\n                natives.removeScriptFire(+obj.fireHandle);\r\n                obj.fireHandle = null;\r\n            }\r\n        }\r\n        obj.onFire = !!onFire;\r\n    }\r\n    setFrozen(obj, frozen) {\r\n        if (frozen === null) {\r\n            return;\r\n        }\r\n        natives.freezeEntityPosition(+obj.handle, !!frozen);\r\n        obj.frozen = !!frozen;\r\n    }\r\n    setLightColor(obj, lightColor) {\r\n        if (lightColor === null) {\r\n            natives.setObjectLightColor(+obj.handle, false, 0, 0, 0);\r\n        }\r\n        else {\r\n            natives.setObjectLightColor(+obj.handle, true, +lightColor.r, +lightColor.g, +lightColor.b);\r\n        }\r\n        obj.lightColor = lightColor;\r\n    }\r\n    moveObject(obj, data) {\r\n        alt.log('data recieved: ', JSON.stringify(data));\r\n        if (data === null) {\r\n            obj.move = null;\r\n        }\r\n        else {\r\n            obj.move = { ...data, speed: data.speed / 100 };\r\n        }\r\n    }\r\n}\r\nfunction calculateNextPosForAxis(currentPos, nextPos, step) {\r\n    if (currentPos !== nextPos) {\r\n        if (Math.abs(currentPos - nextPos) < step) {\r\n            currentPos = nextPos;\r\n        }\r\n        else if (currentPos < nextPos) {\r\n            currentPos += step;\r\n        }\r\n        else {\r\n            currentPos -= step;\r\n        }\r\n    }\r\n    return currentPos;\r\n}\r\nexport const objStreamer = new ObjectStreamer();\r\nexport default async () => {\r\n    alt.on('resourceStop', () => {\r\n        objStreamer.objects.forEach((obj) => {\r\n            objStreamer.removeObject(+obj.entityId, +obj.entityType);\r\n            objStreamer.clearObject(+obj.entityId, +obj.entityType);\r\n        });\r\n    });\r\n    alt.setInterval(() => {\r\n        objStreamer.objects.filter(o => o.move !== null && o.entityType !== OBJECT_TYPES.RWO).forEach((obj) => {\r\n            const pos = {\r\n                x: calculateNextPosForAxis(obj.position.x, obj.move.x, obj.move.speed),\r\n                y: calculateNextPosForAxis(obj.position.y, obj.move.y, obj.move.speed),\r\n                z: calculateNextPosForAxis(obj.position.z, obj.move.z, obj.move.speed),\r\n            };\r\n            natives.setEntityCoordsNoOffset(+obj.handle, pos.x, pos.y, pos.z, true, true, true);\r\n            obj.position = pos;\r\n            if (pos.x === obj.move.x && pos.y === obj.move.y && pos.z === obj.move.z) {\r\n                alt.log('object moved!');\r\n            }\r\n        });\r\n    }, 1);\r\n};\r\n","references":["B:/Projekty/LSGamble-Clientside/lsg-clientside/modules/Streamers/ObjectSteamer/AsyncModel.ts"]}
